"""
scheduler_ai/api.py - API Flask avec Socket.IO pour l'agent IA
Version corrigée avec le bon middleware
"""
import os
import json
import logging
import asyncio
from datetime import datetime
from typing import Dict, Any, Optional

from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from flask_cors import CORS

# Import des modules locaux
from llm_router import LLMRouter
from models import ConstraintType, ConstraintPriority

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialisation Flask
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key-123')

# Configuration CORS
CORS(app, resources={
    r"/*": {
        "origins": ["http://localhost:3000", "http://localhost:3001", "http://localhost:8000"],
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type"],
        "supports_credentials": True
    }
})

# Configuration Socket.IO
socketio = SocketIO(
    app,
    cors_allowed_origins="*",
    async_mode='threading',
    logger=True,
    engineio_logger=True
)

# Initialisation du routeur LLM
llm_router = LLMRouter()

# Sessions actives
active_sessions: Dict[str, Dict[str, Any]] = {}

# ============================================
# MIDDLEWARE DE CLARIFICATION SIMPLIFIÉ
# ============================================

class SimpleClarificationMiddleware:
    """Middleware simplifié pour gérer les clarifications"""
    
    def __init__(self):
        self.sessions = {}
        self.max_attempts = 3
    
    def analyze_constraint(self, text: str, session_id: str, context: Dict = None) -> Dict:
        """Analyse une contrainte et détermine si des clarifications sont nécessaires"""
        
        # Initialiser la session si nécessaire
        if session_id not in self.sessions:
            self.sessions[session_id] = {
                'attempts': 0,
                'history': [],
                'pending_constraint': None
            }
        
        session = self.sessions[session_id]
        session['attempts'] += 1
        
        # Analyse basique du texte
        result = self._parse_constraint(text)
        
        # Vérifier si des clarifications sont nécessaires
        if result.get('needs_clarification'):
            if session['attempts'] >= self.max_attempts:
                return {
                    'status': 'error',
                    'message': 'Impossible de comprendre la contrainte après plusieurs tentatives'
                }
            
            return {
                'status': 'clarification_needed',
                'clarification_questions': result.get('questions', [
                    "Pouvez-vous préciser pour quelle entité (professeur, classe, salle) ?",
                    "Quelle est la période concernée ?"
                ])
            }
        
        # Contrainte comprise
        return {
            'status': 'success',
            'constraint': result['constraint']
        }
    
    def _parse_constraint(self, text: str) -> Dict:
        """Parse basique d'une contrainte"""
        text_lower = text.lower()
        
        # Détection simple des types
        constraint = {
            'type': 'time_preference',
            'entity': 'Global',
            'data': {'original_text': text},
            'confidence': 0.5
        }
        
        # Détection de professeur
        if 'professeur' in text_lower or 'prof' in text_lower or 'מורה' in text:
            constraint['type'] = 'teacher_availability'
            # Essayer d'extraire le nom
            import re
            name_match = re.search(r'(?:professeur|prof\.?)\s+(\w+)', text, re.I)
            if name_match:
                constraint['entity'] = name_match.group(1)
                constraint['confidence'] = 0.8
        
        # Détection de prière
        elif 'prière' in text_lower or 'תפילה' in text or 'tefila' in text_lower:
            constraint['type'] = 'morning_prayer'
            constraint['data'] = {
                'time_slot': '08:00-08:30',
                'mandatory_for': ['all']
            }
            constraint['confidence'] = 0.9
        
        # Détection vendredi
        elif 'vendredi' in text_lower or 'שישי' in text:
            constraint['type'] = 'friday_early_end'
            constraint['data'] = {
                'end_time': '13:00',
                'applies_to': ['all']
            }
            constraint['confidence'] = 0.85
        
        # Vérifier si on a besoin de clarifications
        needs_clarification = constraint['confidence'] < 0.6 or constraint['entity'] == 'Global'
        
        return {
            'constraint': constraint,
            'needs_clarification': needs_clarification,
            'questions': self._generate_questions(constraint) if needs_clarification else []
        }
    
    def _generate_questions(self, constraint: Dict) -> list:
        """Génère des questions de clarification"""
        questions = []
        
        if constraint['entity'] == 'Global':
            questions.append("Pour quelle entité cette contrainte s'applique-t-elle (professeur, classe, salle) ?")
        
        if constraint['type'] == 'time_preference':
            questions.append("Pouvez-vous préciser le type de contrainte (disponibilité, préférence horaire, limite) ?")
        
        if not constraint['data'].get('days') and not constraint['data'].get('time_slot'):
            questions.append("Quels jours ou créneaux horaires sont concernés ?")
        
        return questions[:2]  # Maximum 2 questions à la fois
    
    def clear_session(self, session_id: str):
        """Nettoie une session"""
        if session_id in self.sessions:
            del self.sessions[session_id]

# Initialiser le middleware
clarification_middleware = SimpleClarificationMiddleware()

# ============================================
# ROUTES HTTP
# ============================================

@app.route('/health', methods=['GET'])
def health_check():
    """Vérification de santé de l'API"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'active_sessions': len(active_sessions)
    })

@app.route('/api/ai/apply_constraint', methods=['POST'])
def apply_constraint():
    """Applique une contrainte via HTTP (fallback)"""
    try:
        data = request.json
        constraint_text = data.get('constraint_text', '')
        context = data.get('context', {})
        
        # Créer une session temporaire
        session_id = f"http_{datetime.now().timestamp()}"
        
        # Analyser la contrainte
        result = clarification_middleware.analyze_constraint(
            constraint_text,
            session_id,
            context
        )
        
        # Nettoyer la session temporaire
        clarification_middleware.clear_session(session_id)
        
        return jsonify(result)
        
    except Exception as e:
        logger.error(f"Erreur apply_constraint: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500

# ============================================
# WEBSOCKET HANDLERS
# ============================================

@socketio.on('connect')
def handle_connect():
    """Gestion de la connexion WebSocket"""
    session_id = request.sid
    active_sessions[session_id] = {
        'connected_at': datetime.now().isoformat(),
        'messages_count': 0
    }
    
    emit('connected', {
        'message': 'Agent IA connecté - Prêt à analyser vos contraintes',
        'session_id': session_id,
        'capabilities': [
            'Analyse en français et hébreu',
            'Détection automatique du type de contrainte',
            'Clarifications interactives',
            'Support des contraintes complexes'
        ]
    })
    
    logger.info(f"Nouvelle connexion: {session_id}")

@socketio.on('message')
def handle_message(data):
    """Traite un message de l'utilisateur"""
    session_id = request.sid
    text = data.get('text', '')
    context = data.get('context', {})
    
    logger.info(f"Message reçu de {session_id}: {text[:100]}...")
    
    try:
        # Mettre à jour le compteur
        if session_id in active_sessions:
            active_sessions[session_id]['messages_count'] += 1
        
        # Analyser avec le middleware
        result = clarification_middleware.analyze_constraint(text, session_id, context)
        
        # Envoyer la réponse
        emit('ai_response', result)
        
        logger.info(f"Réponse envoyée: {result['status']}")
        
    except Exception as e:
        logger.error(f"Erreur traitement message: {str(e)}")
        emit('ai_response', {
            'status': 'error',
            'message': f'Erreur lors du traitement: {str(e)}'
        })

@socketio.on('clarification_response')
def handle_clarification_response(data):
    """Gère les réponses aux questions de clarification"""
    session_id = request.sid
    answers = data.get('answers', [])
    original_text = data.get('original_text', '')
    
    logger.info(f"Réponses de clarification reçues de {session_id}")
    
    try:
        # Reconstruire le texte avec les clarifications
        enhanced_text = f"{original_text}\n" + "\n".join(answers)
        
        # Réanalyser avec plus d'informations
        result = clarification_middleware.analyze_constraint(
            enhanced_text,
            session_id,
            data.get('context', {})
        )
        
        emit('ai_response', result)
        
    except Exception as e:
        logger.error(f"Erreur clarification: {str(e)}")
        emit('ai_response', {
            'status': 'error',
            'message': f'Erreur: {str(e)}'
        })

@socketio.on('disconnect')
def handle_disconnect():
    """Gestion de la déconnexion"""
    session_id = request.sid
    
    if session_id in active_sessions:
        session_info = active_sessions[session_id]
        logger.info(f"Déconnexion: {session_id} après {session_info['messages_count']} messages")
        del active_sessions[session_id]
    
    clarification_middleware.clear_session(session_id)

# ============================================
# ROUTES ADDITIONNELLES
# ============================================

@app.route('/api/ai/sessions', methods=['GET'])
def get_sessions():
    """Liste les sessions actives"""
    return jsonify({
        'active_sessions': len(active_sessions),
        'sessions': [
            {
                'id': sid,
                'connected_at': info['connected_at'],
                'messages_count': info['messages_count']
            }
            for sid, info in active_sessions.items()
        ]
    })

@app.route('/api/ai/constraint_types', methods=['GET'])
def get_constraint_types():
    """Retourne les types de contraintes supportés"""
    return jsonify({
        'types': [
            {
                'id': 'teacher_availability',
                'label': 'Disponibilité professeur',
                'description': 'Définit quand un professeur n\'est pas disponible'
            },
            {
                'id': 'morning_prayer',
                'label': 'Prière du matin',
                'description': 'Réserve un créneau pour la prière'
            },
            {
                'id': 'friday_early_end',
                'label': 'Vendredi court',
                'description': 'Fin des cours plus tôt le vendredi'
            },
            {
                'id': 'lunch_break',
                'label': 'Pause déjeuner',
                'description': 'Définit l\'horaire de pause déjeuner'
            },
            {
                'id': 'time_preference',
                'label': 'Préférence horaire',
                'description': 'Préférences générales d\'horaires'
            }
        ]
    })

# ============================================
# POINT D'ENTRÉE
# ============================================

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5001))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    logger.info(f"Démarrage de l'API IA sur le port {port}")
    logger.info(f"Mode: {'development' if debug else 'production'}")
    
    socketio.run(
        app,
        host='0.0.0.0',
        port=port,
        debug=debug,
        use_reloader=False  # Évite les doubles démarrages
    )